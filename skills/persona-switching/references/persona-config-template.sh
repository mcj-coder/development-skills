#!/bin/bash
# Persona Configuration for {{REPO_NAME}}
# Generated by persona-switching skill
#
# IMPORTANT: Set file permissions to 600 (chmod 600 <this-file>)
# This file contains account mappings but no secrets.
#
# Platform: Linux/macOS only (requires bash 4.0+, gpg, gh CLI)
# Windows users: Use WSL2 or Git Bash with GPG4Win
#
# Usage:
#   source ~/.config/{{REPO_NAME}}/persona-config.sh
#   use_persona backend-engineer
#   show_persona

# =============================================================================
# Guard Against Multiple Sourcing (DO-C5)
# =============================================================================

if [ -n "$PERSONA_CONFIG_LOADED_{{REPO_NAME}}" ]; then
    return 0 2>/dev/null || exit 0
fi
export PERSONA_CONFIG_LOADED_{{REPO_NAME}}=1

# =============================================================================
# Runtime Dependency Verification (DO-C1)
# =============================================================================

_verify_dependencies() {
    local missing=()

    if ! command -v git &>/dev/null; then
        missing+=("git")
    fi

    if ! command -v gpg &>/dev/null; then
        missing+=("gpg")
    fi

    if ! command -v gh &>/dev/null; then
        missing+=("gh (GitHub CLI)")
    fi

    # Check bash version for associative arrays
    if [ "${BASH_VERSINFO[0]}" -lt 4 ]; then
        echo "Error: bash 4.0+ required (current: $BASH_VERSION)"
        echo "  macOS: brew install bash"
        echo "  Linux: usually pre-installed"
        return 1
    fi

    if [ ${#missing[@]} -gt 0 ]; then
        echo "Error: Missing required dependencies: ${missing[*]}"
        echo "  Install missing tools and re-source this file"
        return 1
    fi

    return 0
}

if ! _verify_dependencies; then
    unset PERSONA_CONFIG_LOADED_{{REPO_NAME}}
    return 1 2>/dev/null || exit 1
fi

# =============================================================================
# Security Profiles
# Each profile defines a GitHub account, email, and GPG signing key
# =============================================================================

declare -A SECURITY_PROFILES
{{SECURITY_PROFILES}}

# Example profile definitions (replace with your actual configuration):
# SECURITY_PROFILES[contributor_account]="dev-bot-account"
# SECURITY_PROFILES[contributor_email]="dev@company.com"
# SECURITY_PROFILES[contributor_gpg_key]="ABC123DEF456"
#
# SECURITY_PROFILES[maintainer_account]="lead-bot-account"
# SECURITY_PROFILES[maintainer_email]="lead@company.com"
# SECURITY_PROFILES[maintainer_gpg_key]="DEF456GHI789"

# =============================================================================
# Persona-to-Profile Mapping
# Maps logical personas to security profiles
# =============================================================================

declare -A PERSONA_PROFILES
{{PERSONAS}}

# Example persona mappings (replace with your actual configuration):
# PERSONA_PROFILES[backend-engineer]="contributor"
# PERSONA_PROFILES[frontend-engineer]="contributor"
# PERSONA_PROFILES[qa-engineer]="contributor"
# PERSONA_PROFILES[tech-lead]="maintainer"
# PERSONA_PROFILES[security-reviewer]="contributor"

# =============================================================================
# Current Persona State
# =============================================================================

CURRENT_PERSONA=""
PREVIOUS_PERSONA=""
PERSONA_HISTORY=()
PERSONA_CONFIG_DIR="${HOME}/.config/{{REPO_NAME}}"
PERSONA_AUDIT_LOG="${PERSONA_CONFIG_DIR}/persona-audit.log"
PERSONA_LOCK_FILE="${PERSONA_CONFIG_DIR}/.persona.lock"

# Ensure config directory exists
mkdir -p "$PERSONA_CONFIG_DIR" 2>/dev/null
chmod 700 "$PERSONA_CONFIG_DIR" 2>/dev/null

# =============================================================================
# Input Validation Functions (SEC-C1, SEC-C2)
# =============================================================================

_validate_persona_name() {
    local persona="$1"
    # Only allow lowercase letters, numbers, and hyphens
    if [[ ! "$persona" =~ ^[a-z0-9][a-z0-9-]*[a-z0-9]$|^[a-z0-9]$ ]]; then
        echo "Error: Invalid persona name '$persona'"
        echo "  Persona names must:"
        echo "  - Contain only lowercase letters, numbers, and hyphens"
        echo "  - Start and end with a letter or number"
        return 1
    fi
    return 0
}

_validate_email_format() {
    local email="$1"
    # Basic email format validation
    if [[ ! "$email" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        echo "Error: Invalid email format: $email"
        return 1
    fi
    return 0
}

_validate_gpg_key_format() {
    local key="$1"
    if [ -z "$key" ]; then
        return 0  # Empty is allowed (no signing)
    fi
    # GPG key IDs are hex strings (short: 8, long: 16, fingerprint: 40)
    if [[ ! "$key" =~ ^[A-Fa-f0-9]{8,40}$ ]]; then
        echo "Error: Invalid GPG key format: $key"
        echo "  Expected hex string (8-40 characters)"
        return 1
    fi
    return 0
}

# =============================================================================
# Lock File Management (DO-C6)
# =============================================================================

_acquire_lock() {
    local max_wait=10
    local waited=0

    while [ -f "$PERSONA_LOCK_FILE" ]; do
        if [ $waited -ge $max_wait ]; then
            echo "Error: Could not acquire persona lock (another switch in progress?)"
            echo "  If stuck, remove: $PERSONA_LOCK_FILE"
            return 1
        fi
        sleep 1
        ((waited++))
    done

    echo $$ > "$PERSONA_LOCK_FILE"
    return 0
}

_release_lock() {
    rm -f "$PERSONA_LOCK_FILE" 2>/dev/null
}

# =============================================================================
# Audit Logging (DO-C9)
# =============================================================================

_audit_log() {
    local action="$1"
    local details="$2"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # Log to file (persistent)
    echo "[$timestamp] $action: $details" >> "$PERSONA_AUDIT_LOG"

    # Prune old entries (keep last 3 days per user request)
    if [ -f "$PERSONA_AUDIT_LOG" ]; then
        local cutoff
        cutoff=$(date -d '3 days ago' '+%Y-%m-%d' 2>/dev/null || date -v-3d '+%Y-%m-%d' 2>/dev/null)
        if [ -n "$cutoff" ]; then
            local tmp_file="${PERSONA_AUDIT_LOG}.tmp"
            awk -v cutoff="$cutoff" '$0 ~ /^\[/ && substr($0,2,10) >= cutoff' "$PERSONA_AUDIT_LOG" > "$tmp_file" 2>/dev/null
            mv "$tmp_file" "$PERSONA_AUDIT_LOG" 2>/dev/null
        fi
    fi
}

# =============================================================================
# Helper Functions
# =============================================================================

_log_persona_action() {
    local action="$1"
    local persona="$2"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # Session history (in-memory)
    PERSONA_HISTORY+=("[$timestamp] $action: $persona")

    # Persistent audit log (DO-C10)
    _audit_log "$action" "$persona (profile: ${PERSONA_PROFILES[$persona]:-unknown})"
}

_get_gpg_key_email() {
    local key_id="$1"
    gpg --list-keys --with-colons "$key_id" 2>/dev/null | \
        grep '^uid:' | head -1 | cut -d: -f10 | \
        sed -n 's/.*<\([^>]*\)>.*/\1/p'
}

_validate_email_key_match() {
    local email="$1"
    local gpg_key="$2"

    if [ -z "$gpg_key" ]; then
        echo "Warning: No GPG key configured for this profile"
        return 0
    fi

    local key_email
    key_email=$(_get_gpg_key_email "$gpg_key")

    if [ -z "$key_email" ]; then
        echo "Error: Cannot find GPG key $gpg_key"
        echo "  Run: gpg --list-keys $gpg_key"
        return 1
    fi

    if [ "$email" != "$key_email" ]; then
        echo "Error: Email/key mismatch detected!"
        echo "  Configured email: $email"
        echo "  GPG key email:    $key_email"
        echo ""
        echo "  This would cause 'Unverified' commits on GitHub."
        echo "  The signing key's email must match the commit author email."
        echo ""
        echo "  Options to fix:"
        echo "  1. Update profile email to match key: $key_email"
        echo "  2. Add $email as UID to GPG key: gpg --edit-key $gpg_key adduid"
        echo "  3. Generate new key for $email"
        return 1
    fi

    return 0
}

_validate_gpg_key_available() {
    local gpg_key="$1"

    if [ -z "$gpg_key" ]; then
        return 0
    fi

    if ! gpg --list-secret-keys "$gpg_key" &>/dev/null; then
        echo "Error: GPG secret key not found: $gpg_key"
        echo "  Run: gpg --list-secret-keys"
        echo "  To generate: gpg --full-generate-key"
        return 1
    fi

    # Check if key is expired
    local expiry
    expiry=$(gpg --list-keys --with-colons "$gpg_key" 2>/dev/null | \
        grep '^pub:' | cut -d: -f7)

    if [ -n "$expiry" ]; then
        local now
        now=$(date +%s)
        if [ "$expiry" -lt "$now" ]; then
            echo "Error: GPG key $gpg_key has expired"
            return 1
        fi

        # Warn if expiring soon (30 days)
        local days_until_expiry=$(( (expiry - now) / 86400 ))
        if [ "$days_until_expiry" -lt 30 ]; then
            echo "Warning: GPG key expires in $days_until_expiry days"
        fi
    fi

    return 0
}

_save_current_config() {
    SAVED_USER_NAME=$(git config --local user.name 2>/dev/null || git config --global user.name)
    SAVED_USER_EMAIL=$(git config --local user.email 2>/dev/null || git config --global user.email)
    SAVED_SIGNING_KEY=$(git config --local user.signingkey 2>/dev/null || git config --global user.signingkey)
    # DO-C7: Save GitHub account for rollback
    SAVED_GH_ACCOUNT=$(gh auth status 2>&1 | grep "Logged in to" | head -1 | awk '{print $NF}')
}

_restore_saved_config() {
    if [ -n "$SAVED_USER_EMAIL" ]; then
        git config --local user.name "$SAVED_USER_NAME"
        git config --local user.email "$SAVED_USER_EMAIL"
        if [ -n "$SAVED_SIGNING_KEY" ]; then
            git config --local user.signingkey "$SAVED_SIGNING_KEY"
        fi
        # DO-C7: Restore GitHub account
        if [ -n "$SAVED_GH_ACCOUNT" ]; then
            gh auth switch --user "$SAVED_GH_ACCOUNT" 2>/dev/null
        fi
        _audit_log "ROLLBACK" "Restored to: $SAVED_USER_EMAIL"
        echo "Rolled back to previous configuration"
    fi
    _release_lock
}

# =============================================================================
# Main Functions
# =============================================================================

use_persona() {
    local persona="$1"

    if [ -z "$persona" ]; then
        echo "Usage: use_persona <persona-name>"
        echo ""
        echo "Available personas:"
        for p in "${!PERSONA_PROFILES[@]}"; do
            echo "  - $p (${PERSONA_PROFILES[$p]} profile)"
        done
        return 1
    fi

    # SEC-C1: Validate persona name format
    if ! _validate_persona_name "$persona"; then
        return 1
    fi

    # Check if persona exists
    local profile="${PERSONA_PROFILES[$persona]}"
    if [ -z "$profile" ]; then
        echo "Error: Unknown persona '$persona'"
        echo ""
        echo "Available personas:"
        for p in "${!PERSONA_PROFILES[@]}"; do
            echo "  - $p"
        done

        # Suggest similar names (simple substring match)
        for p in "${!PERSONA_PROFILES[@]}"; do
            if [[ "$p" == *"${persona:0:3}"* ]] || [[ "$persona" == *"${p:0:3}"* ]]; then
                echo ""
                echo "Did you mean: $p?"
            fi
        done
        return 1
    fi

    # Get profile configuration
    local account="${SECURITY_PROFILES[${profile}_account]}"
    local email="${SECURITY_PROFILES[${profile}_email]}"
    local gpg_key="${SECURITY_PROFILES[${profile}_gpg_key]}"
    local display_name="${SECURITY_PROFILES[${profile}_name]:-Claude ($persona)}"

    if [ -z "$email" ]; then
        echo "Error: Profile '$profile' is not properly configured (missing email)"
        return 1
    fi

    # SEC-C2: Validate profile data format
    if ! _validate_email_format "$email"; then
        return 1
    fi
    if ! _validate_gpg_key_format "$gpg_key"; then
        return 1
    fi

    # Validate GPG key availability
    if ! _validate_gpg_key_available "$gpg_key"; then
        return 1
    fi

    # Validate email/key match BEFORE making any changes
    if ! _validate_email_key_match "$email" "$gpg_key"; then
        return 1
    fi

    # DO-C6: Acquire lock to prevent concurrent switches
    if ! _acquire_lock; then
        return 1
    fi

    # Save current config for rollback
    _save_current_config
    PREVIOUS_PERSONA="$CURRENT_PERSONA"

    echo "Switching to persona: $persona ($profile profile)"

    # Step 1: Switch GitHub account (if configured and different)
    if [ -n "$account" ]; then
        local current_account
        current_account=$(gh auth status 2>&1 | grep "Logged in to" | head -1 | awk '{print $NF}')

        if [ "$current_account" != "$account" ]; then
            echo "  Switching GitHub account to: $account"
            if ! gh auth switch --user "$account" 2>/dev/null; then
                echo "  Warning: Could not switch GitHub account"
                echo "  You may need to run: gh auth login"
                _audit_log "WARNING" "gh auth switch failed for $account"
            fi
        fi
    fi

    # Step 2: Update Git config atomically
    echo "  Setting Git identity: $display_name <$email>"
    if ! git config --local user.name "$display_name"; then
        echo "Error: Failed to set user.name"
        _restore_saved_config
        return 1
    fi

    if ! git config --local user.email "$email"; then
        echo "Error: Failed to set user.email"
        _restore_saved_config
        return 1
    fi

    if [ -n "$gpg_key" ]; then
        echo "  Setting signing key: $gpg_key"
        if ! git config --local user.signingkey "$gpg_key"; then
            echo "Error: Failed to set signing key"
            _restore_saved_config
            return 1
        fi
    fi

    # Step 3: Verify the switch
    echo "  Verifying configuration..."
    local actual_email
    actual_email=$(git config user.email)
    if [ "$actual_email" != "$email" ]; then
        echo "Error: Email verification failed"
        _restore_saved_config
        return 1
    fi

    # Success - release lock
    _release_lock
    CURRENT_PERSONA="$persona"
    _log_persona_action "SWITCH" "$persona"

    echo ""
    echo "Successfully switched to: $persona"
    show_persona
    return 0
}

show_persona() {
    echo "=== Current Persona ==="

    if [ -n "$CURRENT_PERSONA" ]; then
        echo "Persona:      $CURRENT_PERSONA"
        echo "Profile:      ${PERSONA_PROFILES[$CURRENT_PERSONA]}"
    else
        echo "Persona:      (not set via use_persona)"
    fi

    echo ""
    echo "Git Identity:"
    echo "  Name:       $(git config user.name)"
    echo "  Email:      $(git config user.email)"
    echo "  SigningKey: $(git config user.signingkey || echo '(not set)')"

    echo ""
    echo "GitHub Account:"
    gh auth status 2>&1 | grep -E "(Logged in|account)" | head -2 | sed 's/^/  /'

    # Validate current config
    local current_email current_key
    current_email=$(git config user.email)
    current_key=$(git config user.signingkey)

    if [ -n "$current_key" ]; then
        if ! _validate_email_key_match "$current_email" "$current_key" 2>/dev/null; then
            echo ""
            echo "WARNING: Current configuration has email/key mismatch!"
            echo "         Commits may show as 'Unverified' on GitHub."
        fi
    fi
}

persona_history() {
    echo "=== Persona History (this session) ==="
    if [ ${#PERSONA_HISTORY[@]} -eq 0 ]; then
        echo "No persona switches recorded this session"
    else
        for entry in "${PERSONA_HISTORY[@]}"; do
            echo "$entry"
        done
    fi

    echo ""
    echo "=== Persistent Audit Log (last 3 days) ==="
    if [ -f "$PERSONA_AUDIT_LOG" ]; then
        cat "$PERSONA_AUDIT_LOG"
    else
        echo "No persistent log found"
    fi
}

# DO-C4: Health check command for setup verification
persona_health_check() {
    echo "=== Persona Configuration Health Check ==="
    local errors=0
    local warnings=0

    # Check 1: Dependencies
    echo ""
    echo "1. Dependencies:"
    for cmd in git gpg gh; do
        if command -v "$cmd" &>/dev/null; then
            local ver
            case "$cmd" in
                git) ver=$(git --version | awk '{print $3}') ;;
                gpg) ver=$(gpg --version | head -1 | awk '{print $3}') ;;
                gh)  ver=$(gh --version | head -1 | awk '{print $3}') ;;
            esac
            echo "   ✓ $cmd ($ver)"
        else
            echo "   ✗ $cmd NOT FOUND"
            ((errors++))
        fi
    done

    # Check 2: Bash version
    echo ""
    echo "2. Bash version:"
    if [ "${BASH_VERSINFO[0]}" -ge 4 ]; then
        echo "   ✓ bash ${BASH_VERSION} (4.0+ required)"
    else
        echo "   ✗ bash ${BASH_VERSION} (4.0+ required)"
        ((errors++))
    fi

    # Check 3: Config file permissions
    echo ""
    echo "3. Config file permissions:"
    local config_file="${PERSONA_CONFIG_DIR}/persona-config.sh"
    if [ -f "$config_file" ]; then
        local perms
        perms=$(stat -c '%a' "$config_file" 2>/dev/null || stat -f '%Lp' "$config_file" 2>/dev/null)
        if [ "$perms" = "600" ]; then
            echo "   ✓ $config_file (mode 600)"
        else
            echo "   ⚠ $config_file (mode $perms, should be 600)"
            ((warnings++))
        fi
    else
        echo "   - Config file not yet created"
    fi

    # Check 4: GPG agent
    echo ""
    echo "4. GPG agent:"
    if gpg-connect-agent /bye &>/dev/null; then
        echo "   ✓ GPG agent is running"
    else
        echo "   ⚠ GPG agent not responding (may need to start it)"
        ((warnings++))
    fi

    # Check 5: GitHub authentication
    echo ""
    echo "5. GitHub CLI authentication:"
    if gh auth status &>/dev/null; then
        local gh_user
        gh_user=$(gh auth status 2>&1 | grep "Logged in to" | head -1)
        echo "   ✓ $gh_user"
    else
        echo "   ✗ Not authenticated (run: gh auth login)"
        ((errors++))
    fi

    # Check 6: Current Git config
    echo ""
    echo "6. Current Git identity:"
    local git_email git_key
    git_email=$(git config user.email 2>/dev/null)
    git_key=$(git config user.signingkey 2>/dev/null)
    if [ -n "$git_email" ]; then
        echo "   Email: $git_email"
        if [ -n "$git_key" ]; then
            echo "   Signing key: $git_key"
            # Check email/key match
            if _validate_email_key_match "$git_email" "$git_key" &>/dev/null; then
                echo "   ✓ Email/key match valid"
            else
                echo "   ✗ Email/key MISMATCH (commits will be Unverified)"
                ((errors++))
            fi
        else
            echo "   ⚠ No signing key configured"
            ((warnings++))
        fi
    else
        echo "   ⚠ No email configured"
        ((warnings++))
    fi

    # Check 7: Profile validation
    echo ""
    echo "7. Profile validation:"
    validate_persona_config 2>/dev/null | grep -E '(Profile:|Status:)' | sed 's/^/   /'

    # Summary
    echo ""
    echo "=== Summary ==="
    if [ $errors -eq 0 ] && [ $warnings -eq 0 ]; then
        echo "✓ All checks passed - configuration is healthy"
        return 0
    elif [ $errors -eq 0 ]; then
        echo "⚠ $warnings warning(s) - configuration may work but review recommended"
        return 0
    else
        echo "✗ $errors error(s), $warnings warning(s) - configuration needs attention"
        return 1
    fi
}

validate_persona_config() {
    echo "=== Validating Persona Configuration ==="
    local errors=0

    for profile in contributor maintainer admin; do
        local email="${SECURITY_PROFILES[${profile}_email]}"
        local gpg_key="${SECURITY_PROFILES[${profile}_gpg_key]}"

        if [ -z "$email" ]; then
            continue  # Profile not configured
        fi

        echo ""
        echo "Profile: $profile"
        echo "  Email: $email"
        echo "  GPG Key: ${gpg_key:-'(not set)'}"

        if [ -n "$gpg_key" ]; then
            if ! _validate_gpg_key_available "$gpg_key"; then
                ((errors++))
            elif ! _validate_email_key_match "$email" "$gpg_key"; then
                ((errors++))
            else
                echo "  Status: OK"
            fi
        else
            echo "  Status: No GPG key (signing disabled)"
        fi
    done

    echo ""
    if [ $errors -gt 0 ]; then
        echo "Found $errors configuration error(s)"
        return 1
    else
        echo "All configured profiles are valid"
        return 0
    fi
}

# =============================================================================
# Initialization
# =============================================================================

# Validate configuration on source (optional - comment out if slow)
# validate_persona_config

echo "Persona configuration loaded for {{REPO_NAME}}"
echo "Run 'show_persona' to see current identity"
echo "Run 'use_persona <name>' to switch personas"
