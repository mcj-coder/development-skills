# Check for unsigned or invalid commits before pushing
# This prevents pushing commits that won't pass the signed commits requirement

REMOTE="$1"
URL="$2"

# Detect the default branch for remediation instructions
DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
if [ -z "$DEFAULT_BRANCH" ]; then
  DEFAULT_BRANCH="main"
fi

refs_checked=0

resolve_github_repo() {
  remote_url=$(git remote get-url origin 2>/dev/null)
  if [ -z "$remote_url" ]; then
    return 1
  fi

  repo=$(echo "$remote_url" | sed -E 's#(git@|https?://)github.com[:/]##' | sed -E 's#\.git$##')
  if echo "$repo" | grep -q '/'; then
    echo "$repo"
    return 0
  fi

  return 1
}

is_github_verified() {
  repo="$1"
  commit_sha="$2"

  if ! command -v gh >/dev/null 2>&1; then
    return 1
  fi

  verified=$(gh api "repos/$repo/commits/$commit_sha" --jq '.commit.verification.verified' 2>/dev/null)
  if [ "$verified" = "true" ]; then
    return 0
  fi

  return 1
}

is_on_default_branch() {
  commit_sha="$1"

  if ! git show-ref --verify --quiet "refs/remotes/origin/$DEFAULT_BRANCH"; then
    return 1
  fi

  git merge-base --is-ancestor "$commit_sha" "origin/$DEFAULT_BRANCH" 2>/dev/null
}

# Get the range of commits being pushed
while read local_ref local_sha remote_ref remote_sha; do
  if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
    # Branch is being deleted, skip
    continue
  fi

  # Skip tag pushes - tags have separate signing requirements
  if echo "$local_ref" | grep -q '^refs/tags/'; then
    continue
  fi

  refs_checked=$((refs_checked + 1))

  if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
    # New branch - check commits not in the default branch
    merge_base=$(git merge-base "origin/$DEFAULT_BRANCH" "$local_sha" 2>/dev/null)
    if [ -n "$merge_base" ]; then
      range="$merge_base..$local_sha"
    else
      # Fallback: can't find merge base, check last 50 commits
      range="$local_sha~50..$local_sha"
    fi
  else
    # Existing branch, check new commits only
    range="$remote_sha..$local_sha"
  fi

  # Check for invalid signatures: N=None, B=Bad, E=Error, R=Revoked, X/Y=Expired
  # Valid signatures are G (Good) and U (Good but untrusted)
  invalid_commits=$(git log --format="%H %G?" "$range" 2>/dev/null | grep -vE " [GU]$" | cut -d' ' -f1)
  filtered_invalid_commits=""

  for commit in $invalid_commits; do
    if is_on_default_branch "$commit"; then
      continue
    fi
    filtered_invalid_commits="$filtered_invalid_commits $commit"
  done

  if [ -n "$filtered_invalid_commits" ]; then
    github_repo=""
    github_verified_commits=""
    remaining_invalid_commits=""

    if command -v gh >/dev/null 2>&1; then
      github_repo=$(resolve_github_repo)
    fi

    for commit in $filtered_invalid_commits; do
      if [ -n "$github_repo" ] && is_github_verified "$github_repo" "$commit"; then
        github_verified_commits="$github_verified_commits $commit"
      else
        remaining_invalid_commits="$remaining_invalid_commits $commit"
      fi
    done

    if [ -n "$github_verified_commits" ]; then
      echo ""
      echo "?? Commits verified by GitHub (local verification failed):"
      for commit in $github_verified_commits; do
        echo "  - $(git log -1 --format='%h %s' "$commit")"
      done
    fi

    if [ -z "$remaining_invalid_commits" ]; then
      continue
    fi

    echo ""
    echo "? ERROR: Found commits with invalid or missing signatures"
    echo ""
    echo "Problematic commits:"
    for commit in $remaining_invalid_commits; do
      sig_status=$(git log -1 --format="%G?" "$commit" 2>/dev/null)
      case "$sig_status" in
        N) sig_desc="unsigned" ;;
        B) sig_desc="bad signature" ;;
        E) sig_desc="cannot verify (missing key)" ;;
        R) sig_desc="revoked key" ;;
        X) sig_desc="expired signature" ;;
        Y) sig_desc="expired key" ;;
        *) sig_desc="unknown status: $sig_status" ;;
      esac
      echo "  - $(git log -1 --format='%h %s' "$commit") [$sig_desc]"
    done
    echo ""
    if [ -z "$github_repo" ]; then
      echo "GitHub verification was unavailable (missing gh CLI or non-GitHub origin)."
      echo ""
    fi
    echo "To fix, rebase and re-sign your commits:"
    echo ""
    echo "  git rebase origin/$DEFAULT_BRANCH --exec 'git commit --amend --no-edit -S'"
    echo ""
    echo "Then force push:"
    echo ""
    echo "  git push --force-with-lease"
    echo ""
    echo "See: docs/playbooks/enable-signed-commits.md"
    echo ""
    echo "??  To bypass (not recommended): git push --no-verify"
    exit 1
  fi
done

exit 0
